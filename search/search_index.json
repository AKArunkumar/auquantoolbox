{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Note : This the documentation for the current version toolbox released by Auquan. The old, stripped down version (installed as auquanToolbox, has been deprecated). You can see the current toolbox repository here - if you face any bugs, please open an issue on the github repository or email us at: toolbox@auquan.com Welcome to Auquan Toolbox Auquan provides a backtesting toolbox to develop your trading algorithms. The toolbox is free and open source which you can use to create and backtest strategies. Table of Contents Demo Video Installation Guide How does the toolbox work? Quick Setup Getting Data - DataSource Specifying Features - Instrument, Market and Custom Features Prediction Function Final Metrics Importing a trained model Under the Hood - Trading System DataSource Benchmark Starting Capital Frequency Of Feature Updates PriceFeatureKey Lookback Size Instrument Features, Market Features and Custom Features Prediction Function ExecutionSystem OrderPlacer ML Training System Installation DataSource DataSplit Ratio InstrumentFeatureConfigDicts CustomFeatures Target Variable FeatureSelectionConfigDicts FeatureTransformationConfigDicts Model Config Dicts Prediction Function Demo Video You can watch a quick video demo for the toolbox below Installation Guide Install Python and dependent packages Our toolbox is compatible with both Python 2.7( there are currently some issues with Python 3, we'll fix them shortly). The easiest way to install Python is through Anaconda since it will reliably install all the necessary dependencies. Download Anaconda and follow the instructions on the installation page . Once you have Python, you can then install the toolbox. Get the Auquan Toolbox There are multiple ways to install the toolbox for the competition. Via pip : The easiest way and the most recommended way is via pip. Just run the following command: pip install -U auquan_toolbox . If we publish any updates to the toolbox, the same command pip install -U auquan_toolbox will also automatically get the new version of the toolbox. Note: Mac users , if you face any issues with installation, try using pip install --user auquan_toolbox Via git : Clone/Download this repository. git clone https://{your_username}@bitbucket.org/auquan/auquantoolbox.git Download this sample file and navigate to the place where you downloaded it (if you cloned the repo, the file is already present). Go inside that folder and run the following code to make sure everything is setup properly. python my_trading_params.py Use my_trading_params.py as a template which contains skeleton functions (with explanation) that need to be filled in to create your own trading strategy. Copy that template to another file and then start implementing the methods in that file. You can use pair_trading_params.py and meanreversion_trading_params.py as motivation. How does the toolbox work? Any security you want to trade with the toolbox is called an instrument . Right now, the toolbox supports stock and future instruments. All the parameters for the toolbox are supplied in class MyTradingParams() . Quick Setup To get started quickly with the toolbox, you need to Get Historical Data Specify Features to be created from the Data Create a prediction function using above features to make your prediction for the market The toolbox can handle everything else for you. You can do the above by modifying the following functions: Getting Data - DataSource Data Source parses data from external sources (csv, log file, html file etc) and loads and converts it into a toolbox compatible form. You need to specify the instrumentID's that you need data for and start and end date for data in in getDataParser() function. def getDataParser(self): instrumentIds = ['IBM', 'AAPL', 'MSFT'] startDateStr = '2017/05/10' endDateStr = '2017/06/09' return YahooStockDataSource(cachedFolderName='yahooData', instrumentIds=instrumentIds, startDateStr=startDateStr, endDateStr=endDateStr) Current choices for datasource are: * YahooStockDataSource - Stock data from Yahoo (daily data) * NSEStockDataSource - Stock data from NSE (daily data) * AuquanDataSource - Data from US stock database of 500 biggest stocks maintained by Auquan. Specifying Features - Instrument, Market and Custom Features You can manipulate historical data by creating features. Features are called by specifying config dictionaries. You have to: Create one config dictionary per feature. Feature config Dictionary has the following keys: featureId: string representing the feature you want to use featureKey: {optional} string representing key to access value of this feature. If not present, use featureId params: {optional} A dictionary with which contains other parameters, if needed by the feature Return an array of all feature config dictionaries as market features or instrument features. Specify the instrument features in function getInstrumentFeatureConfigDicts() and market features in function getMarketFeatureConfigDicts() . Instrument features are calculated per instrument (for example position, fees, moving average of instrument price). The toolbox auto-loops through all instruments to calculate features for you. Market features are calculated for whole trading system (for example portfolio value). Example : If you want to use the moving_sum feature and calculate this for all instruments, your getInstrumentFeatureConfigDicts() function should be: def getInstrumentFeatureConfigDicts(self): msDict = {'featureKey': 'ms_5', 'featureId': 'moving_sum', 'params': {'period': 5, 'featureName': 'basis'}} return [msDict] You can now use this feature by calling it's featureKey, 'ms_5'. Full list of features with featureId and params is available here . Custom Features - Optional To use your own custom features, you need to create them separately. Follow the example of this template . Specifically, you'll have to: Create a new class for the feature and implement your logic. You can copy the template from this file . Example: If you were implementing a new InstrumentFeature class MyCustomFeatureClassName(Feature): @classmethod def computeForInstrument(cls, featureParams, featureKey, currentFeatures, instrument, instrumentManager): return 5 Modify function getCustomFeatures() to return a dictionary with key: featureId to access this feature (Make sure this doesn't conflict with any of the pre defined feature Ids) value: Your custom Class Name which computes this feature. The class should be an instance of Feature Eg. to use the feature we create above via featureId='my_custom_feature_identifier', def getCustomFeatures(self): return {'my_custom_feature_identifier': MyCustomFeatureClassName} Now you can create a dict for this feature in getInstrumentFeatureConfigDicts() . Dict format is: customFeatureDict = {'featureKey': 'my_custom_feature_key', 'featureId': 'my_custom_feature_identifier', 'params': {'param1': 'value1'}} Use this feature by calling it's featureKey, 'my_custom_feature_key' Prediction Function Combine all the features to create the desired prediction function. Fill the funtion getPrediction() to return the prediction for instrument you are trading. Here you can call your previously created features by referencing their featureId. For example, I can call my moving sum and custom feature as: def getPrediction(self, time, currentMarketFeatures, instrumentManager): # holder for all the instrument features lookbackInstrumentFeatures = instrumentManager.getLookbackInstrumentFeatures() ms5Data = lookbackInstrumentFeatures.getFeatureDf('ms_5') # dataframe for a historical instrument feature (ms_5 in this case). # The index is the timestamps of atmost lookback data points. # The last row of this data frame would contain the features # which are being calculated in this update cycle or for this time. # The second to last row (if exists) would have the features for the previous # time update. # The columns of this dataframe are the stock symbols/instrumentIds. ms5 = ms5Data.iloc[-1] # This returns the value of the feature at the last time update # Returns a series with index as all the instrumentIds. customData = lookbackInstrumentFeatures.getFeatureDf('my_custom_feature_key') custom = customData.iloc[-1] predictions = ms5 / custom return predictions Predictions can be of many types. You can calculate(predict) the FairValue of a parameter, for example price. You can predict the probability that price will increase in the future. You can predict the ratio of price of two securities. You can predict the ranking of a basket of securities. Output of the prediction function is used by the toolbox to make further trading decisions via the execution system . Choice of execution system depends on the type of prediction made. Final Metrics The system returns the following final metrics: Total PnL: Total Profit(or Loss) from your strategy as a % of initial capital Annualized Return: The yearly average % Profit(or Loss) from your trading strategy Annualized Volatility: The standard deviation of daily returns of the model in a year. Volatility is used as a measure of risk, therefore higher vol implies riskier model. Sharpe Ratio: The reward/risk ratio or risk adjusted returns of the strategy, calculated as Annualized Return/Annualized Volatility Sortino Ratio: Returns adjusted for downside risk, calculated as Annualized Return/Annualized Volatility of Negative Returns Max Drawdown: Largest drop in Pnl or maximum negative difference in total portfolio value. It is calculated as the maximum high to subsequent low difference before a new high is reached. Win/Loss, Average Profit/Loss: Sum(or Avergae) of Profits from trades that results in profits/Sum(or Average) of losses from trades that results in losses % Profitability = % of total trades that resulted in profits Return on Capital = Total Profit(or Loss) from your strategy as a % of max capital used Other Metrics can be supported if needed. Importing a trained model If you would like to write your own custom datasource/execution system or you want to import a pre-trained ML model, you can do so in the manner below. Here we store a file training_execution_system.py on github. Then we specify the path to file, and the code downloads the file as fileName and imports the required class from it. import urllib path_to_file = 'https://raw.githubusercontent.com/Auquan/quant-quest-2/master/training_execution_system.py' fileName = 'training_execution_system.py' if not os.path.isfile(fileName): urllib.urlretrieve (path_to_file, fileName) from training_execution_system import TrainingExecutionSystem Under the Hood - Trading System This is the main system that runs your backtest. All the parameters for the trading system are supplied in class MyTradingParams() Raw data (intraday tick data or end of day data) is read from the datasource for all instruments and sent to the trading system. At every such update of data, the trading system does the following things and then updates the state of that instrument in the system : Checks whether it is time to update the features and execute. It updates features at a frequency determined by trading parameters. If it is, it first loops over all instruments and updates the features for each instrument (specified by trading parameters). Each instrument stores its features, which can be later extracted out. Then, the trading system computes all the market features (specified by trading parameters). The system also stores such market features at every update features interval. An example of market feature is 'prediction' which the user needs to provide - This feaure specifies our prediction probability that the specified instrument is a buy Then the trading system looks at the prediction value and passes it to an execution system. This converts uses the prediction value (and current capital, risk limits etc) to decide what positions should he trading system take for various instruments. Trade executions generated by Execution System are then passed into the orderPlacer, which tries to place these orders into the market. Trading System also keeps checking for confirmation of orders which are placed. It updates instrument positions for trades that are confirmed. For trading system to work, following need to be specified: DataSource Read Above Benchmark The market instrument to benchmark your strategy's perfromancy. Strategies that perform better than the benchmark are considered successful. Make sure that you specify the benchmark instrumentID in list of instruments to get data for. Starting Capital The initial amount of money you're putting into your trading system. This is set to 1 million notional by default. Frequency Of Feature Updates Frequency of updates to features. Any updates within this frequncy to instruments do not trigger feature updates. Consequently any trading decisions that need to take place happen with the same frequency This is important when you are working with frequently updating data - for example intraday tick data PriceFeatureKey You may have multiple measures of price for an instrument at the same time, for example open price, close price etc. Specify which price to use for pnl calculations. By default, this is set to 'close' for daily calculations. Lookback Size How far back do you want the historical data for your calculations. The historical market features and instrument features are only stored upto this amount. The more data you request, the slower your system will be. Instrument Features, Market Features and Custom Features Read Above Prediction Function Read Above ExecutionSystem Takes a prediction value and converts it into possible trades for each instrument. It takes into account current positions, risk limits, current capital and value of the prediction. All execution systems take the following arguments: 'longLimit': Max long position. No buys if instrument position == longLimit, can be specified as dollar or lot size 'shortLimit': Max short position. No sells if instrument position == shortLimit, can be specified as dollar or lot size 'capitalUsageLimit': Minimum capital threshold, specified as % of initial capital. No trades if currentCapital/initialCapital < capitalUsageLimit 'lotSize': Size to trade per trade, can be specified as dollar or lot size 'limitType': 'D' for dollar(monetary) limit, 'L' for lot size limit 'price': Feature to use as price Right now we support following executions: System Description Parameters Snippet SimpleExecutionSystem Simplest type, takes prediction in the form of probability that price will go up. Instruments with probability of price increasing above enter_threshold are bought and below (1-enter_threshold) are sold. Instrument positions with probability predictions values between (1-exit_threshold) and exit_threshold are closed 'enter_threshold', 'exit_threshold', 'longLimit', 'shortLimit', 'capitalUsageLimit', 'lotSize', 'limitType', 'price' SimpleExecutionSystemWithFairValue Takes prediction in the form of FairValue of price. Instruments with CurrentPrice - FairValue > enter_threshold_deviation are sold and FairValue - CurrentPrice > enter_threshold_deviation are bought. Instrument positions with abs(CurrentPrice - FairValue) < exit_threshold_deviation are closed 'enter_threshold_deviation', 'exit_threshold_deviation', 'longLimit', 'shortLimit', 'capitalUsageLimit', 'lotSize', 'limitType', 'price' PairExecutionSystem , PairExecutionSystemWithFairValue Behaves the same as above two, except predictions are made on ratio of prices between two instruments(pair) 'pair', 'pairRatio','enter_threshold_deviation', 'exit_threshold_deviation', 'longLimit', 'shortLimit', 'capitalUsageLimit', 'lotSize', 'limitType', 'price' OrderPlacer Execution System decided what trades you want to do, order placer actually makes those trades (place an order), and also reads confirmations of orders being placed. For Backtesting, you can just use the BacktestingOrderPlacer, which places the order and automatically trades at 'PriceFeatureKey' price at the same time. ML Training System To make creation and testing of ML models easy for you, we are providing you with a ML model creation suite. This is a beta feature, so please bear with us while we iron out the bugs! Installation Get the toolbox by typing the following commands in your terminal: pip uninstall auquan_toolbox pip install -U auquan_toolbox_beta --no-cache-dir For ML Training system to work, following need to be specified: DataSource Similar to Trading System above. DataSplit Ratio A list specifying the percentage of Training, Validation and Test Data. Eg [6,2,2]. The model is trained and validated on Training and Validation data respectively and then backtested for trading on Test Data. InstrumentFeatureConfigDicts Similar to Trading System above. CustomFeatures Similar to Trading System above. Target Variable The Variable you want to predict. This can be one or many variables. They can be specified as one of the features created above (with a shift) or loaded from a file as below: getTargetVariableConfigDicts(self): Y = {'featureKey' : 'Y', #Use a feature loaded from datasource 'featureId' : '', 'params' : {}} tv = {'featureKey' : 'direction_tv', ##Create a target variable from a feature 'featureId' : 'direction', 'params' : {'period' : 5, 'featureName' : 'ma_5', 'shift' : 5}} return {INSTRUMENT_TYPE_STOCK : [tv]} FeatureSelectionConfigDicts Use this to specify the methods to be used for feature engineering. For example, you can choose to reduce the overall set of features by keeping only those features which display a certain minimum correlation to target Variable. Current Available methods are: def getFeatureSelectionConfigDicts(self): corr = {'featureSelectionKey': 'corr', 'featureSelectionId' : 'pearson_correlation', 'params' : {'startPeriod' : 0, 'endPeriod' : 60, 'steps' : 10, 'threshold' : 0.1, 'topK' : 2}} genericSelect = {'featureSelectionKey' : 'gus', 'featureSelectionId' : 'generic_univariate_select', 'params' : {'scoreFunction' : 'f_classif', 'mode' : 'k_best', 'modeParam' : 'all'}} rfecvSelect = {'featureSelectionKey': 'rfecv', 'featureSelectionId': 'rfecv_selection', 'params' : {'estimator' : 'LinearRegression', 'estimator_params' : {}, 'step' : 1, 'cv' : None, 'scoring' : None, 'n_jobs' : 2}} return {INSTRUMENT_TYPE_STOCK : [genericSelect]} FeatureTransformationConfigDicts The methods you want to use to normalize or transform features. Current available methods are: def getFeatureTransformationConfigDicts(self): stdScaler = {'featureTransformKey': 'stdScaler', 'featureTransformId' : 'standard_transform', 'params' : {}} minmaxScaler = {'featureTransformKey' : 'minmaxScaler', 'featureTransformId' : 'minmax_transform', 'params' : {'low' : -1, 'high' : 1}} pcaScaler = {'featureTransformKey' : 'pcaScaler', 'featureTransformId' : 'pca_transform', 'params' : {'n_comp' : 6, 'copy' : True, 'whiten' : False, 'svd' : 'full', 'itr_power' : 'auto', 'random_state' : None}} return {INSTRUMENT_TYPE_STOCK : [stdScaler]} Model Config Dicts The ML models you want to train. Current available models are: def getModelConfigDicts(self): regression_model = {'modelKey': 'linear_regression', 'modelId' : 'linear_regression', 'params' : {}} mlp_regression_model = {'modelKey': 'mlp_regression', 'modelId' : 'mlp_regression', 'params' : {}} classification_model = {'modelKey': 'logistic_regression', 'modelId' : 'logistic_regression', 'params' : {}} mlp_classification_model = {'modelKey': 'mlp_classification', 'modelId' : 'mlp_classification', 'params' : {}} svm_model = {'modelKey': 'svm_model', 'modelId' : 'support_vector_machine', 'params' : {}} return {INSTRUMENT_TYPE_STOCK : [classification_model]} Prediction Function You do not have to specify a prediction function. The toolbox automatically creates a prediction function using the features and trained model from above.","title":"Home"},{"location":"#demo-video","text":"You can watch a quick video demo for the toolbox below","title":"Demo Video"},{"location":"#installation-guide","text":"Install Python and dependent packages Our toolbox is compatible with both Python 2.7( there are currently some issues with Python 3, we'll fix them shortly). The easiest way to install Python is through Anaconda since it will reliably install all the necessary dependencies. Download Anaconda and follow the instructions on the installation page . Once you have Python, you can then install the toolbox. Get the Auquan Toolbox There are multiple ways to install the toolbox for the competition. Via pip : The easiest way and the most recommended way is via pip. Just run the following command: pip install -U auquan_toolbox . If we publish any updates to the toolbox, the same command pip install -U auquan_toolbox will also automatically get the new version of the toolbox. Note: Mac users , if you face any issues with installation, try using pip install --user auquan_toolbox Via git : Clone/Download this repository. git clone https://{your_username}@bitbucket.org/auquan/auquantoolbox.git Download this sample file and navigate to the place where you downloaded it (if you cloned the repo, the file is already present). Go inside that folder and run the following code to make sure everything is setup properly. python my_trading_params.py Use my_trading_params.py as a template which contains skeleton functions (with explanation) that need to be filled in to create your own trading strategy. Copy that template to another file and then start implementing the methods in that file. You can use pair_trading_params.py and meanreversion_trading_params.py as motivation.","title":"Installation Guide"},{"location":"#how-does-the-toolbox-work","text":"Any security you want to trade with the toolbox is called an instrument . Right now, the toolbox supports stock and future instruments. All the parameters for the toolbox are supplied in class MyTradingParams() .","title":"How does the toolbox work?"},{"location":"#quick-setup","text":"To get started quickly with the toolbox, you need to Get Historical Data Specify Features to be created from the Data Create a prediction function using above features to make your prediction for the market The toolbox can handle everything else for you. You can do the above by modifying the following functions:","title":"Quick Setup"},{"location":"#getting-data-datasource","text":"Data Source parses data from external sources (csv, log file, html file etc) and loads and converts it into a toolbox compatible form. You need to specify the instrumentID's that you need data for and start and end date for data in in getDataParser() function. def getDataParser(self): instrumentIds = ['IBM', 'AAPL', 'MSFT'] startDateStr = '2017/05/10' endDateStr = '2017/06/09' return YahooStockDataSource(cachedFolderName='yahooData', instrumentIds=instrumentIds, startDateStr=startDateStr, endDateStr=endDateStr) Current choices for datasource are: * YahooStockDataSource - Stock data from Yahoo (daily data) * NSEStockDataSource - Stock data from NSE (daily data) * AuquanDataSource - Data from US stock database of 500 biggest stocks maintained by Auquan.","title":"Getting Data - DataSource"},{"location":"#specifying-features-instrument-market-and-custom-features","text":"You can manipulate historical data by creating features. Features are called by specifying config dictionaries. You have to: Create one config dictionary per feature. Feature config Dictionary has the following keys: featureId: string representing the feature you want to use featureKey: {optional} string representing key to access value of this feature. If not present, use featureId params: {optional} A dictionary with which contains other parameters, if needed by the feature Return an array of all feature config dictionaries as market features or instrument features. Specify the instrument features in function getInstrumentFeatureConfigDicts() and market features in function getMarketFeatureConfigDicts() . Instrument features are calculated per instrument (for example position, fees, moving average of instrument price). The toolbox auto-loops through all instruments to calculate features for you. Market features are calculated for whole trading system (for example portfolio value). Example : If you want to use the moving_sum feature and calculate this for all instruments, your getInstrumentFeatureConfigDicts() function should be: def getInstrumentFeatureConfigDicts(self): msDict = {'featureKey': 'ms_5', 'featureId': 'moving_sum', 'params': {'period': 5, 'featureName': 'basis'}} return [msDict] You can now use this feature by calling it's featureKey, 'ms_5'. Full list of features with featureId and params is available here . Custom Features - Optional To use your own custom features, you need to create them separately. Follow the example of this template . Specifically, you'll have to: Create a new class for the feature and implement your logic. You can copy the template from this file . Example: If you were implementing a new InstrumentFeature class MyCustomFeatureClassName(Feature): @classmethod def computeForInstrument(cls, featureParams, featureKey, currentFeatures, instrument, instrumentManager): return 5 Modify function getCustomFeatures() to return a dictionary with key: featureId to access this feature (Make sure this doesn't conflict with any of the pre defined feature Ids) value: Your custom Class Name which computes this feature. The class should be an instance of Feature Eg. to use the feature we create above via featureId='my_custom_feature_identifier', def getCustomFeatures(self): return {'my_custom_feature_identifier': MyCustomFeatureClassName} Now you can create a dict for this feature in getInstrumentFeatureConfigDicts() . Dict format is: customFeatureDict = {'featureKey': 'my_custom_feature_key', 'featureId': 'my_custom_feature_identifier', 'params': {'param1': 'value1'}} Use this feature by calling it's featureKey, 'my_custom_feature_key'","title":"Specifying Features - Instrument, Market and Custom Features"},{"location":"#prediction-function","text":"Combine all the features to create the desired prediction function. Fill the funtion getPrediction() to return the prediction for instrument you are trading. Here you can call your previously created features by referencing their featureId. For example, I can call my moving sum and custom feature as: def getPrediction(self, time, currentMarketFeatures, instrumentManager): # holder for all the instrument features lookbackInstrumentFeatures = instrumentManager.getLookbackInstrumentFeatures() ms5Data = lookbackInstrumentFeatures.getFeatureDf('ms_5') # dataframe for a historical instrument feature (ms_5 in this case). # The index is the timestamps of atmost lookback data points. # The last row of this data frame would contain the features # which are being calculated in this update cycle or for this time. # The second to last row (if exists) would have the features for the previous # time update. # The columns of this dataframe are the stock symbols/instrumentIds. ms5 = ms5Data.iloc[-1] # This returns the value of the feature at the last time update # Returns a series with index as all the instrumentIds. customData = lookbackInstrumentFeatures.getFeatureDf('my_custom_feature_key') custom = customData.iloc[-1] predictions = ms5 / custom return predictions Predictions can be of many types. You can calculate(predict) the FairValue of a parameter, for example price. You can predict the probability that price will increase in the future. You can predict the ratio of price of two securities. You can predict the ranking of a basket of securities. Output of the prediction function is used by the toolbox to make further trading decisions via the execution system . Choice of execution system depends on the type of prediction made.","title":"Prediction Function"},{"location":"#final-metrics","text":"The system returns the following final metrics: Total PnL: Total Profit(or Loss) from your strategy as a % of initial capital Annualized Return: The yearly average % Profit(or Loss) from your trading strategy Annualized Volatility: The standard deviation of daily returns of the model in a year. Volatility is used as a measure of risk, therefore higher vol implies riskier model. Sharpe Ratio: The reward/risk ratio or risk adjusted returns of the strategy, calculated as Annualized Return/Annualized Volatility Sortino Ratio: Returns adjusted for downside risk, calculated as Annualized Return/Annualized Volatility of Negative Returns Max Drawdown: Largest drop in Pnl or maximum negative difference in total portfolio value. It is calculated as the maximum high to subsequent low difference before a new high is reached. Win/Loss, Average Profit/Loss: Sum(or Avergae) of Profits from trades that results in profits/Sum(or Average) of losses from trades that results in losses % Profitability = % of total trades that resulted in profits Return on Capital = Total Profit(or Loss) from your strategy as a % of max capital used Other Metrics can be supported if needed.","title":"Final Metrics"},{"location":"#importing-a-trained-model","text":"If you would like to write your own custom datasource/execution system or you want to import a pre-trained ML model, you can do so in the manner below. Here we store a file training_execution_system.py on github. Then we specify the path to file, and the code downloads the file as fileName and imports the required class from it. import urllib path_to_file = 'https://raw.githubusercontent.com/Auquan/quant-quest-2/master/training_execution_system.py' fileName = 'training_execution_system.py' if not os.path.isfile(fileName): urllib.urlretrieve (path_to_file, fileName) from training_execution_system import TrainingExecutionSystem","title":"Importing a trained model"},{"location":"#under-the-hood-trading-system","text":"This is the main system that runs your backtest. All the parameters for the trading system are supplied in class MyTradingParams() Raw data (intraday tick data or end of day data) is read from the datasource for all instruments and sent to the trading system. At every such update of data, the trading system does the following things and then updates the state of that instrument in the system : Checks whether it is time to update the features and execute. It updates features at a frequency determined by trading parameters. If it is, it first loops over all instruments and updates the features for each instrument (specified by trading parameters). Each instrument stores its features, which can be later extracted out. Then, the trading system computes all the market features (specified by trading parameters). The system also stores such market features at every update features interval. An example of market feature is 'prediction' which the user needs to provide - This feaure specifies our prediction probability that the specified instrument is a buy Then the trading system looks at the prediction value and passes it to an execution system. This converts uses the prediction value (and current capital, risk limits etc) to decide what positions should he trading system take for various instruments. Trade executions generated by Execution System are then passed into the orderPlacer, which tries to place these orders into the market. Trading System also keeps checking for confirmation of orders which are placed. It updates instrument positions for trades that are confirmed. For trading system to work, following need to be specified:","title":"Under the Hood - Trading System"},{"location":"#datasource","text":"Read Above","title":"DataSource"},{"location":"#benchmark","text":"The market instrument to benchmark your strategy's perfromancy. Strategies that perform better than the benchmark are considered successful. Make sure that you specify the benchmark instrumentID in list of instruments to get data for.","title":"Benchmark"},{"location":"#starting-capital","text":"The initial amount of money you're putting into your trading system. This is set to 1 million notional by default.","title":"Starting Capital"},{"location":"#frequency-of-feature-updates","text":"Frequency of updates to features. Any updates within this frequncy to instruments do not trigger feature updates. Consequently any trading decisions that need to take place happen with the same frequency This is important when you are working with frequently updating data - for example intraday tick data","title":"Frequency Of Feature Updates"},{"location":"#pricefeaturekey","text":"You may have multiple measures of price for an instrument at the same time, for example open price, close price etc. Specify which price to use for pnl calculations. By default, this is set to 'close' for daily calculations.","title":"PriceFeatureKey"},{"location":"#lookback-size","text":"How far back do you want the historical data for your calculations. The historical market features and instrument features are only stored upto this amount. The more data you request, the slower your system will be.","title":"Lookback Size"},{"location":"#instrument-features-market-features-and-custom-features","text":"Read Above","title":"Instrument Features, Market Features and Custom Features"},{"location":"#prediction-function_1","text":"Read Above","title":"Prediction Function"},{"location":"#executionsystem","text":"Takes a prediction value and converts it into possible trades for each instrument. It takes into account current positions, risk limits, current capital and value of the prediction. All execution systems take the following arguments: 'longLimit': Max long position. No buys if instrument position == longLimit, can be specified as dollar or lot size 'shortLimit': Max short position. No sells if instrument position == shortLimit, can be specified as dollar or lot size 'capitalUsageLimit': Minimum capital threshold, specified as % of initial capital. No trades if currentCapital/initialCapital < capitalUsageLimit 'lotSize': Size to trade per trade, can be specified as dollar or lot size 'limitType': 'D' for dollar(monetary) limit, 'L' for lot size limit 'price': Feature to use as price Right now we support following executions: System Description Parameters Snippet SimpleExecutionSystem Simplest type, takes prediction in the form of probability that price will go up. Instruments with probability of price increasing above enter_threshold are bought and below (1-enter_threshold) are sold. Instrument positions with probability predictions values between (1-exit_threshold) and exit_threshold are closed 'enter_threshold', 'exit_threshold', 'longLimit', 'shortLimit', 'capitalUsageLimit', 'lotSize', 'limitType', 'price' SimpleExecutionSystemWithFairValue Takes prediction in the form of FairValue of price. Instruments with CurrentPrice - FairValue > enter_threshold_deviation are sold and FairValue - CurrentPrice > enter_threshold_deviation are bought. Instrument positions with abs(CurrentPrice - FairValue) < exit_threshold_deviation are closed 'enter_threshold_deviation', 'exit_threshold_deviation', 'longLimit', 'shortLimit', 'capitalUsageLimit', 'lotSize', 'limitType', 'price' PairExecutionSystem , PairExecutionSystemWithFairValue Behaves the same as above two, except predictions are made on ratio of prices between two instruments(pair) 'pair', 'pairRatio','enter_threshold_deviation', 'exit_threshold_deviation', 'longLimit', 'shortLimit', 'capitalUsageLimit', 'lotSize', 'limitType', 'price'","title":"ExecutionSystem"},{"location":"#orderplacer","text":"Execution System decided what trades you want to do, order placer actually makes those trades (place an order), and also reads confirmations of orders being placed. For Backtesting, you can just use the BacktestingOrderPlacer, which places the order and automatically trades at 'PriceFeatureKey' price at the same time.","title":"OrderPlacer"},{"location":"#ml-training-system","text":"To make creation and testing of ML models easy for you, we are providing you with a ML model creation suite. This is a beta feature, so please bear with us while we iron out the bugs!","title":"ML Training System"},{"location":"#installation","text":"Get the toolbox by typing the following commands in your terminal: pip uninstall auquan_toolbox pip install -U auquan_toolbox_beta --no-cache-dir For ML Training system to work, following need to be specified:","title":"Installation"},{"location":"#datasource_1","text":"Similar to Trading System above.","title":"DataSource"},{"location":"#datasplit-ratio","text":"A list specifying the percentage of Training, Validation and Test Data. Eg [6,2,2]. The model is trained and validated on Training and Validation data respectively and then backtested for trading on Test Data.","title":"DataSplit Ratio"},{"location":"#instrumentfeatureconfigdicts","text":"Similar to Trading System above.","title":"InstrumentFeatureConfigDicts"},{"location":"#customfeatures","text":"Similar to Trading System above.","title":"CustomFeatures"},{"location":"#target-variable","text":"The Variable you want to predict. This can be one or many variables. They can be specified as one of the features created above (with a shift) or loaded from a file as below: getTargetVariableConfigDicts(self): Y = {'featureKey' : 'Y', #Use a feature loaded from datasource 'featureId' : '', 'params' : {}} tv = {'featureKey' : 'direction_tv', ##Create a target variable from a feature 'featureId' : 'direction', 'params' : {'period' : 5, 'featureName' : 'ma_5', 'shift' : 5}} return {INSTRUMENT_TYPE_STOCK : [tv]}","title":"Target Variable"},{"location":"#featureselectionconfigdicts","text":"Use this to specify the methods to be used for feature engineering. For example, you can choose to reduce the overall set of features by keeping only those features which display a certain minimum correlation to target Variable. Current Available methods are: def getFeatureSelectionConfigDicts(self): corr = {'featureSelectionKey': 'corr', 'featureSelectionId' : 'pearson_correlation', 'params' : {'startPeriod' : 0, 'endPeriod' : 60, 'steps' : 10, 'threshold' : 0.1, 'topK' : 2}} genericSelect = {'featureSelectionKey' : 'gus', 'featureSelectionId' : 'generic_univariate_select', 'params' : {'scoreFunction' : 'f_classif', 'mode' : 'k_best', 'modeParam' : 'all'}} rfecvSelect = {'featureSelectionKey': 'rfecv', 'featureSelectionId': 'rfecv_selection', 'params' : {'estimator' : 'LinearRegression', 'estimator_params' : {}, 'step' : 1, 'cv' : None, 'scoring' : None, 'n_jobs' : 2}} return {INSTRUMENT_TYPE_STOCK : [genericSelect]}","title":"FeatureSelectionConfigDicts"},{"location":"#featuretransformationconfigdicts","text":"The methods you want to use to normalize or transform features. Current available methods are: def getFeatureTransformationConfigDicts(self): stdScaler = {'featureTransformKey': 'stdScaler', 'featureTransformId' : 'standard_transform', 'params' : {}} minmaxScaler = {'featureTransformKey' : 'minmaxScaler', 'featureTransformId' : 'minmax_transform', 'params' : {'low' : -1, 'high' : 1}} pcaScaler = {'featureTransformKey' : 'pcaScaler', 'featureTransformId' : 'pca_transform', 'params' : {'n_comp' : 6, 'copy' : True, 'whiten' : False, 'svd' : 'full', 'itr_power' : 'auto', 'random_state' : None}} return {INSTRUMENT_TYPE_STOCK : [stdScaler]}","title":"FeatureTransformationConfigDicts"},{"location":"#model-config-dicts","text":"The ML models you want to train. Current available models are: def getModelConfigDicts(self): regression_model = {'modelKey': 'linear_regression', 'modelId' : 'linear_regression', 'params' : {}} mlp_regression_model = {'modelKey': 'mlp_regression', 'modelId' : 'mlp_regression', 'params' : {}} classification_model = {'modelKey': 'logistic_regression', 'modelId' : 'logistic_regression', 'params' : {}} mlp_classification_model = {'modelKey': 'mlp_classification', 'modelId' : 'mlp_classification', 'params' : {}} svm_model = {'modelKey': 'svm_model', 'modelId' : 'support_vector_machine', 'params' : {}} return {INSTRUMENT_TYPE_STOCK : [classification_model]}","title":"Model Config Dicts"},{"location":"#prediction-function_2","text":"You do not have to specify a prediction function. The toolbox automatically creates a prediction function using the features and trained model from above.","title":"Prediction Function"},{"location":"Introduction/","text":"Welcome to Auquan Toolbox Auquan provides a backtesting toolbox to develop your trading algorithms. The toolbox is free and open source which you can use to create and backtest strategies. Table of Contents Quick Startup Guide How does the toolbox work? Trading System DataSource Benchmark Starting Capital Frequency Of Feature Updates PriceFeatureKey Lookback Size InstrumentFeatures, Market Features and Custom Features Prediction Function ExecutionSystem OrderPlacer Available Feature Guide Quick Startup Guide Install Python and dependent packages You need Python 2.7 (Python 3 will be supported later) to run this toolbox. For an easy installation process, we recommend Anaconda since it will reliably install all the necessary dependencies. Download Anaconda and follow the instructions on the installation page . Once you have Python,install the following packages. Easiest way is via pip numpy pandas pandas-datareader plotly Clone/Download this repository. git clone https://{your_username}@bitbucket.org/auquan/auquantoolbox.git Navigate to the place where you downloaded the repo. Go inside that folder and run the following code to make sure everything is setup properly. python my_trading_params.py Use my_trading_params.py as a template which contains skeleton functions (with explanation) that need to be filled in to create your own trading strategy. Copy that template to another file and then start implementing the methods in that file. You can use pair_trading_params.py and meanreversion_trading_params.py as motivation. How does the toolbox work? Trading System The main system that runs your backtest. Raw data (intraday tick data or end of day data) for instruments are sent to the trading system. At every such update of data, the trading system does the following things and then updates the state of that instrument in the system : Checks whether it is time to update the features and execute. It updates features at a frequency determined by trading parameters. If it is, it first loops over all instruments and updates the features for each instrument (specified by trading parameters). Each instrument stores its features, which can be later extracted out. Then, the trading system computes all the market features (specified by trading parameters). The system also stores such market features at every update features interval. An example of market feature is 'prediction' which the user needs to provide - This feaure specifies our prediction probability that the specified instrument is a buy Then the trading system looks at the prediction value and passes it to an execution system. This converts uses the prediction value (and current capital, risk limits etc) to decide what positions should he trading system take for various instruments. Trade executions generated by Execution System are then passed into the orderPlacer, which tries to place these orders into the market. Trading System also keeps checking for confirmation of orders which are placed. It updates instrument positions for trades that are confirmed. For trading system to work, following need to be specified: DataSource Emits instrument updates into the trading system. It converts any sort of data from external sources to Instrument Updates. We have a different instrument update for each type of instrument. You need to specify the instrumentID's that you need data for and start and end date for data. Current choices for datasource are: GoogleStockDataSource - Stock data from Google AuquanDataSource - Data from US stock database of 500 biggest stocks maintained by Auquan. Benchmark The market instrument to benchmark your strategy's perfromancy. Strategies that perform better than the benchmark are considered successful. Make sure that you specify the benchmark instrumentID in list of instruments to get data for. Starting Capital The initial amount of money you're putting into your trading system. This is set to 1 million notional by default. Frequency Of Feature Updates Frequency of updates to features. Any updates within this frequncy to instruments do not trigger feature updates. Consequently any trading decisions that need to take place happen with the same frequency This is important when you are working with frequently updating data - for example intraday tick data PriceFeatureKey You may have multiple measures of price for an instrument at the same time, for example open price, close price etc. Specify which price to use for pnl calculations. By default, this is set to 'close' for daily calculations. Lookback Size How far back do you want the historical data for your calculations. The historical market features and instrument features are only stored upto this amount. The more data you request, the slower your system will be. InstrumentFeatures, Market Features and Custom Features Features can be called by specifying config dictionaries. Create one dictionary per feature and return them in a dictionary as market features or instrument features. Instrument features are calculated per instrument (for example position, fees) and market features are calculated for whole trading system (for example portfolio value) Feature config Dictionary has the following keys: featureId: a string representing the type of feature you want to use featureKey: {optional} a string representing the key you will use to access the value of this feature If not present, will just use featureId params: {optional} A dictionary with which contains other optional params if needed by the feature Full list of features is available here . To use your own custom features(you need to create them separately using this template , return a dictionary where key: featureId to access this feature (Make sure this doesnt conflict with any of the pre defined feature Ids) value: Your custom Class which computes this feature. The class should be an instance of Feature Eg. if your custom class is MyCustomFeature, and you want to access this via featureId='my_custom_feature', you will import that class, and return this function as {'my_custom_feature': MyCustomFeature} Prediction Function Combine all the features to create a prediction function which should output the probability that a given instrument is a buy. An predicted value of 1 means instrument is a guaranteed buy, 0 means a guaranteed sell and 0.5 means it's trading at fair price (neither a buy or a sell) ExecutionSystem Takes a prediction value and converts it into possible trades for each instrument. It takes into account current positions, risk limits, current capital and value of the prediction. Instruments with probability predictions values above enter_threshold are bought and below (1-enter_threshold) are sold. Instrument positions with probability predictions values between (1-exit_threshold) and exit_threshold are closed Current choices are: Simple Execution System Pair Execution System OrderPlacer It helps place an order, and also read confirmations of orders being placed. For Backtesting, you can just use the BacktestingOrderPlacer, which places the order and automatically trades at 'PriceFeatureKey' price. Available Feature Guide Features can be called by specifying config dictionaries. Create one dictionary per feature and return them in a dictionary as market features or instrument features. Feature config Dictionary has the following keys: featureId: a string representing the type of feature you want to use featureKey: {optional} a string representing the key you will use to access the value of this feature If not present, will just use featureId params: {optional} A dictionary with which contains other optional params if needed by the feature Feature ID Parameters Description moving_average 'featureName', 'period' calculate rolling average of featureName over period moving_correlation 'period', 'series1', 'series2' calculate rolling correlation of series1 and series2 over period moving_max 'featureName', 'period' calculate rolling max of featureName over period moving_min 'featureName', 'period' calculate rolling min of featureName over period moving_sdev 'featureName', 'period' calculate moving standard deviation of featureName over period moving_sum 'featureName', 'period' calculate moving sum of featureName over period exponential_moving_average 'featureName', 'period' calculate exp. weighted moving average of featureName with period as half life argmax 'featureName', 'period' Returns the index where featureName is maximum over period argmin 'featureName', 'period' Returns the index where featureName is minimum over period delay 'featureName', 'period' Returns the value of featureName with a delay of period difference 'featureName', 'period' Returns the difference of featureName with it's value period before rank 'featureName', 'period' Ranks last period values of featureName on a scale of 0 to 1 scale 'featureName', 'period', 'scale' Resale last period values of featureName on a scale of 0 to scale ratio 'featureName', 'instrumentId1', 'instrumentId2' ratio of feature values of instrumentID1 / instrumentID2 momentum 'featureName', 'period' calculate momentum in featureName over period as featureValue(now) - featureValue(now - period) bollinger_bands 'featureName', 'period' upper and lower bollinger bands as average(period) - sdev(period), average(period) + sdev(period) cross_sectional_momentum 'featureName', 'period', 'instrumentIds' Returns Cross-Section Momentum of 'instrumentIds' in featureName over period macd 'featureName', 'period1', 'period2' moving average convergence divergence as average(period1) - average(period2) rsi 'featureName', 'period' Relative Strength Index - ratio of average profits / average losses over period vwap - calculated from book data as bid price x ask volume + ask price x bid volume / (ask volume + bid volume) fees - fees to trade, always calculated position - instrument position, always calculated pnl - Profit/Loss, always calculated capital - Spare capital not in use, always calculated portfolio_value - Total value of trading system, always calculated","title":"Introduction"},{"location":"Introduction/#quick-startup-guide","text":"Install Python and dependent packages You need Python 2.7 (Python 3 will be supported later) to run this toolbox. For an easy installation process, we recommend Anaconda since it will reliably install all the necessary dependencies. Download Anaconda and follow the instructions on the installation page . Once you have Python,install the following packages. Easiest way is via pip numpy pandas pandas-datareader plotly Clone/Download this repository. git clone https://{your_username}@bitbucket.org/auquan/auquantoolbox.git Navigate to the place where you downloaded the repo. Go inside that folder and run the following code to make sure everything is setup properly. python my_trading_params.py Use my_trading_params.py as a template which contains skeleton functions (with explanation) that need to be filled in to create your own trading strategy. Copy that template to another file and then start implementing the methods in that file. You can use pair_trading_params.py and meanreversion_trading_params.py as motivation.","title":"Quick Startup Guide"},{"location":"Introduction/#how-does-the-toolbox-work","text":"","title":"How does the toolbox work?"},{"location":"Introduction/#trading-system","text":"The main system that runs your backtest. Raw data (intraday tick data or end of day data) for instruments are sent to the trading system. At every such update of data, the trading system does the following things and then updates the state of that instrument in the system : Checks whether it is time to update the features and execute. It updates features at a frequency determined by trading parameters. If it is, it first loops over all instruments and updates the features for each instrument (specified by trading parameters). Each instrument stores its features, which can be later extracted out. Then, the trading system computes all the market features (specified by trading parameters). The system also stores such market features at every update features interval. An example of market feature is 'prediction' which the user needs to provide - This feaure specifies our prediction probability that the specified instrument is a buy Then the trading system looks at the prediction value and passes it to an execution system. This converts uses the prediction value (and current capital, risk limits etc) to decide what positions should he trading system take for various instruments. Trade executions generated by Execution System are then passed into the orderPlacer, which tries to place these orders into the market. Trading System also keeps checking for confirmation of orders which are placed. It updates instrument positions for trades that are confirmed. For trading system to work, following need to be specified:","title":"Trading System"},{"location":"Introduction/#datasource","text":"Emits instrument updates into the trading system. It converts any sort of data from external sources to Instrument Updates. We have a different instrument update for each type of instrument. You need to specify the instrumentID's that you need data for and start and end date for data. Current choices for datasource are: GoogleStockDataSource - Stock data from Google AuquanDataSource - Data from US stock database of 500 biggest stocks maintained by Auquan.","title":"DataSource"},{"location":"Introduction/#benchmark","text":"The market instrument to benchmark your strategy's perfromancy. Strategies that perform better than the benchmark are considered successful. Make sure that you specify the benchmark instrumentID in list of instruments to get data for.","title":"Benchmark"},{"location":"Introduction/#starting-capital","text":"The initial amount of money you're putting into your trading system. This is set to 1 million notional by default.","title":"Starting Capital"},{"location":"Introduction/#frequency-of-feature-updates","text":"Frequency of updates to features. Any updates within this frequncy to instruments do not trigger feature updates. Consequently any trading decisions that need to take place happen with the same frequency This is important when you are working with frequently updating data - for example intraday tick data","title":"Frequency Of Feature Updates"},{"location":"Introduction/#pricefeaturekey","text":"You may have multiple measures of price for an instrument at the same time, for example open price, close price etc. Specify which price to use for pnl calculations. By default, this is set to 'close' for daily calculations.","title":"PriceFeatureKey"},{"location":"Introduction/#lookback-size","text":"How far back do you want the historical data for your calculations. The historical market features and instrument features are only stored upto this amount. The more data you request, the slower your system will be.","title":"Lookback Size"},{"location":"Introduction/#instrumentfeatures-market-features-and-custom-features","text":"Features can be called by specifying config dictionaries. Create one dictionary per feature and return them in a dictionary as market features or instrument features. Instrument features are calculated per instrument (for example position, fees) and market features are calculated for whole trading system (for example portfolio value) Feature config Dictionary has the following keys: featureId: a string representing the type of feature you want to use featureKey: {optional} a string representing the key you will use to access the value of this feature If not present, will just use featureId params: {optional} A dictionary with which contains other optional params if needed by the feature Full list of features is available here . To use your own custom features(you need to create them separately using this template , return a dictionary where key: featureId to access this feature (Make sure this doesnt conflict with any of the pre defined feature Ids) value: Your custom Class which computes this feature. The class should be an instance of Feature Eg. if your custom class is MyCustomFeature, and you want to access this via featureId='my_custom_feature', you will import that class, and return this function as {'my_custom_feature': MyCustomFeature}","title":"InstrumentFeatures, Market Features and Custom Features"},{"location":"Introduction/#prediction-function","text":"Combine all the features to create a prediction function which should output the probability that a given instrument is a buy. An predicted value of 1 means instrument is a guaranteed buy, 0 means a guaranteed sell and 0.5 means it's trading at fair price (neither a buy or a sell)","title":"Prediction Function"},{"location":"Introduction/#executionsystem","text":"Takes a prediction value and converts it into possible trades for each instrument. It takes into account current positions, risk limits, current capital and value of the prediction. Instruments with probability predictions values above enter_threshold are bought and below (1-enter_threshold) are sold. Instrument positions with probability predictions values between (1-exit_threshold) and exit_threshold are closed Current choices are: Simple Execution System Pair Execution System","title":"ExecutionSystem"},{"location":"Introduction/#orderplacer","text":"It helps place an order, and also read confirmations of orders being placed. For Backtesting, you can just use the BacktestingOrderPlacer, which places the order and automatically trades at 'PriceFeatureKey' price.","title":"OrderPlacer"},{"location":"Introduction/#available-feature-guide","text":"Features can be called by specifying config dictionaries. Create one dictionary per feature and return them in a dictionary as market features or instrument features. Feature config Dictionary has the following keys: featureId: a string representing the type of feature you want to use featureKey: {optional} a string representing the key you will use to access the value of this feature If not present, will just use featureId params: {optional} A dictionary with which contains other optional params if needed by the feature Feature ID Parameters Description moving_average 'featureName', 'period' calculate rolling average of featureName over period moving_correlation 'period', 'series1', 'series2' calculate rolling correlation of series1 and series2 over period moving_max 'featureName', 'period' calculate rolling max of featureName over period moving_min 'featureName', 'period' calculate rolling min of featureName over period moving_sdev 'featureName', 'period' calculate moving standard deviation of featureName over period moving_sum 'featureName', 'period' calculate moving sum of featureName over period exponential_moving_average 'featureName', 'period' calculate exp. weighted moving average of featureName with period as half life argmax 'featureName', 'period' Returns the index where featureName is maximum over period argmin 'featureName', 'period' Returns the index where featureName is minimum over period delay 'featureName', 'period' Returns the value of featureName with a delay of period difference 'featureName', 'period' Returns the difference of featureName with it's value period before rank 'featureName', 'period' Ranks last period values of featureName on a scale of 0 to 1 scale 'featureName', 'period', 'scale' Resale last period values of featureName on a scale of 0 to scale ratio 'featureName', 'instrumentId1', 'instrumentId2' ratio of feature values of instrumentID1 / instrumentID2 momentum 'featureName', 'period' calculate momentum in featureName over period as featureValue(now) - featureValue(now - period) bollinger_bands 'featureName', 'period' upper and lower bollinger bands as average(period) - sdev(period), average(period) + sdev(period) cross_sectional_momentum 'featureName', 'period', 'instrumentIds' Returns Cross-Section Momentum of 'instrumentIds' in featureName over period macd 'featureName', 'period1', 'period2' moving average convergence divergence as average(period1) - average(period2) rsi 'featureName', 'period' Relative Strength Index - ratio of average profits / average losses over period vwap - calculated from book data as bid price x ask volume + ask price x bid volume / (ask volume + bid volume) fees - fees to trade, always calculated position - instrument position, always calculated pnl - Profit/Loss, always calculated capital - Spare capital not in use, always calculated portfolio_value - Total value of trading system, always calculated","title":"Available Feature Guide"},{"location":"prebuilt_feature_guide/","text":"Prebuilt Feature Guide Features can be called by specifying config dictionaries. Create one dictionary per feature and return them in a dictionary as market features or instrument features. Feature config Dictionary has the following keys: featureId: a string representing the type of feature you want to use featureKey: {optional} a string representing the key you will use to access the value of this feature If not present, will just use featureId params: {optional} A dictionary with which contains other optional params if needed by the feature Code Snippets for all the features are available below Feature ID Parameters Description moving_average 'featureName', 'period' calculate rolling average of featureName over period moving_correlation 'period', 'series1', 'series2' calculate rolling correlation of series1 and series2 over period moving_max 'featureName', 'period' calculate rolling max of featureName over period moving_min 'featureName', 'period' calculate rolling min of featureName over period moving_sdev 'featureName', 'period' calculate moving standard deviation of featureName over period moving_sum 'featureName', 'period' calculate moving sum of featureName over period exponential_moving_average 'featureName', 'period' calculate exp. weighted moving average of featureName with period as half life argmax 'featureName', 'period' Returns the index where featureName is maximum over period argmin 'featureName', 'period' Returns the index where featureName is minimum over period delay 'featureName', 'period' Returns the value of featureName with a delay of period difference 'featureName', 'period' Returns the difference of featureName with it's value period before rank 'featureName', 'period' Ranks last period values of featureName on a scale of 0 to 1 scale 'featureName', 'period', 'scale' Resale last period values of featureName on a scale of 0 to scale ratio 'featureName', 'instrumentId1', 'instrumentId2' ratio of feature values of instrumentID1 / instrumentID2 momentum 'featureName', 'period' calculate momentum in featureName over period as featureValue(now) - featureValue(now - period) bollinger_bands 'featureName', 'period' upper and lower bollinger bands as average(period) - sdev(period), average(period) + sdev(period) bollinger_bands_lower 'featureName', 'period' lower bollinger bands as average(period) - sdev(period) bollinger_bands_upper 'featureName', 'period' upper bollinger bands as average(period) + sdev(period) cross_sectional_momentum 'featureName', 'period', 'instrumentIds' Returns Cross-Section Momentum of 'instrumentIds' in featureName over period macd 'featureName', 'period1', 'period2' moving average convergence divergence as average(period1) - average(period2) rsi 'featureName', 'period' Relative Strength Index - ratio of average profits / average losses over period vwap - calculated from book data as bid price x ask volume + ask price x bid volume / (ask volume + bid volume) fees - fees to trade, always calculated position - instrument position, always calculated pnl - Profit/Loss, always calculated capital - Spare capital not in use, always calculated portfolio_value - Total value of trading system, always calculated Examples moving_avg = {'featureKey': 'ma_5', 'featureId': 'moving_average', 'params': {'period': 5, 'featureName': 'stockTopAskPrice'}} moving_max = {'featureKey': 'moving_max', 'featureId': 'moving_max', 'params': {'period': 5, 'featureName': 'stockTopAskPrice'}} moving_min = {'featureKey': 'moving_min', 'featureId': 'moving_min', 'params': {'period': 5, 'featureName': 'basis'}} moving_sdev = {'featureKey': 'moving_sdev', 'featureId': 'moving_sdev', 'params': {'period': 5, 'featureName': 'basis'}} moving_sum = {'featureKey': 'moving_sum', 'featureId': 'moving_sum', 'params': {'period': 5, 'featureName': 'basis'}} ema = {'featureKey': 'exponential_moving_average', 'featureId': 'exponential_moving_average', 'params': {'period': 5, 'featureName': 'basis'}} argmax = {'featureKey': 'argmax', 'featureId': 'argmax', 'params': {'period': 5, 'featureName': 'basis'}} argmin = {'featureKey': 'argmin', 'featureId': 'argmin', 'params': {'period': 5, 'featureName': 'basis'}} delay = {'featureKey': 'delay', 'featureId': 'delay', 'params': {'period': 5, 'featureName': 'basis'}} diff = {'featureKey': 'difference', 'featureId': 'difference', 'params': {'period': 5, 'featureName': 'basis'}} rank = {'featureKey': 'rank', 'featureId': 'rank', 'params': {'period': 5, 'featureName': 'basis'}} scale = {'featureKey': 'scale', 'featureId': 'scale', 'params': {'period': 5, 'featureName': 'basis', 'scale': 3}} mmt = {'featureKey': 'momentum', 'featureId': 'momentum', 'params': {'period': 5, 'featureName': 'basis'}} rankDict = {'featureKey': 'rank', 'featureId': 'rank', 'params': {'period': 5, 'featureName': 'stockVWAP'}} bbandlowerDict = {'featureKey': 'bollinger_bands_lower', 'featureId': 'bollinger_bands_lower', 'params': {'period': 30, 'featureName': 'stockVWAP'}} bbandupperDict = {'featureKey': 'bollinger_bands_upper', 'featureId': 'bollinger_bands_upper', 'params': {'period': 30, 'featureName': 'stockVWAP'}} rsi = {'featureKey': 'rsi', 'featureId': 'rsi', 'params': {'period': 5, 'featureName': 'basis'}} vwap = {'featureKey': 'vwap', 'featureId': 'vwap'} fees = {'featureKey': 'fees', 'featureId': 'fees'} position = {'featureKey': 'position', 'featureId': 'position'} pnl = {'featureKey': 'pnl', 'featureId': 'pnl'} capital = {'featureKey': 'capital', 'featureId': 'capital'} portfolio_value = {'featureKey': 'portfolio_value', 'featureId': 'portfolio_value'} macd = {'featureKey': 'macd', 'featureId': 'macd', 'params': {'period1': 5, 'period2': 10, 'featureName': 'basis'}} csm = {'featureKey': 'cross_sectional_momentum', 'featureId': 'cross_sectional_momentum', 'params': {'period': 5, 'featureName': 'basis'}} ratio = {'featureKey': 'ratio', 'featureId': 'ratio', 'params': {'instrumentId1': \"IBM\", 'instumentId2': \"MSFT\" 'featureName': 'basis'}}","title":"Prebuilt Feature Guide"},{"location":"prebuilt_feature_guide/#prebuilt-feature-guide","text":"Features can be called by specifying config dictionaries. Create one dictionary per feature and return them in a dictionary as market features or instrument features. Feature config Dictionary has the following keys: featureId: a string representing the type of feature you want to use featureKey: {optional} a string representing the key you will use to access the value of this feature If not present, will just use featureId params: {optional} A dictionary with which contains other optional params if needed by the feature Code Snippets for all the features are available below Feature ID Parameters Description moving_average 'featureName', 'period' calculate rolling average of featureName over period moving_correlation 'period', 'series1', 'series2' calculate rolling correlation of series1 and series2 over period moving_max 'featureName', 'period' calculate rolling max of featureName over period moving_min 'featureName', 'period' calculate rolling min of featureName over period moving_sdev 'featureName', 'period' calculate moving standard deviation of featureName over period moving_sum 'featureName', 'period' calculate moving sum of featureName over period exponential_moving_average 'featureName', 'period' calculate exp. weighted moving average of featureName with period as half life argmax 'featureName', 'period' Returns the index where featureName is maximum over period argmin 'featureName', 'period' Returns the index where featureName is minimum over period delay 'featureName', 'period' Returns the value of featureName with a delay of period difference 'featureName', 'period' Returns the difference of featureName with it's value period before rank 'featureName', 'period' Ranks last period values of featureName on a scale of 0 to 1 scale 'featureName', 'period', 'scale' Resale last period values of featureName on a scale of 0 to scale ratio 'featureName', 'instrumentId1', 'instrumentId2' ratio of feature values of instrumentID1 / instrumentID2 momentum 'featureName', 'period' calculate momentum in featureName over period as featureValue(now) - featureValue(now - period) bollinger_bands 'featureName', 'period' upper and lower bollinger bands as average(period) - sdev(period), average(period) + sdev(period) bollinger_bands_lower 'featureName', 'period' lower bollinger bands as average(period) - sdev(period) bollinger_bands_upper 'featureName', 'period' upper bollinger bands as average(period) + sdev(period) cross_sectional_momentum 'featureName', 'period', 'instrumentIds' Returns Cross-Section Momentum of 'instrumentIds' in featureName over period macd 'featureName', 'period1', 'period2' moving average convergence divergence as average(period1) - average(period2) rsi 'featureName', 'period' Relative Strength Index - ratio of average profits / average losses over period vwap - calculated from book data as bid price x ask volume + ask price x bid volume / (ask volume + bid volume) fees - fees to trade, always calculated position - instrument position, always calculated pnl - Profit/Loss, always calculated capital - Spare capital not in use, always calculated portfolio_value - Total value of trading system, always calculated","title":"Prebuilt Feature Guide"},{"location":"prebuilt_feature_guide/#examples","text":"moving_avg = {'featureKey': 'ma_5', 'featureId': 'moving_average', 'params': {'period': 5, 'featureName': 'stockTopAskPrice'}} moving_max = {'featureKey': 'moving_max', 'featureId': 'moving_max', 'params': {'period': 5, 'featureName': 'stockTopAskPrice'}} moving_min = {'featureKey': 'moving_min', 'featureId': 'moving_min', 'params': {'period': 5, 'featureName': 'basis'}} moving_sdev = {'featureKey': 'moving_sdev', 'featureId': 'moving_sdev', 'params': {'period': 5, 'featureName': 'basis'}} moving_sum = {'featureKey': 'moving_sum', 'featureId': 'moving_sum', 'params': {'period': 5, 'featureName': 'basis'}} ema = {'featureKey': 'exponential_moving_average', 'featureId': 'exponential_moving_average', 'params': {'period': 5, 'featureName': 'basis'}} argmax = {'featureKey': 'argmax', 'featureId': 'argmax', 'params': {'period': 5, 'featureName': 'basis'}} argmin = {'featureKey': 'argmin', 'featureId': 'argmin', 'params': {'period': 5, 'featureName': 'basis'}} delay = {'featureKey': 'delay', 'featureId': 'delay', 'params': {'period': 5, 'featureName': 'basis'}} diff = {'featureKey': 'difference', 'featureId': 'difference', 'params': {'period': 5, 'featureName': 'basis'}} rank = {'featureKey': 'rank', 'featureId': 'rank', 'params': {'period': 5, 'featureName': 'basis'}} scale = {'featureKey': 'scale', 'featureId': 'scale', 'params': {'period': 5, 'featureName': 'basis', 'scale': 3}} mmt = {'featureKey': 'momentum', 'featureId': 'momentum', 'params': {'period': 5, 'featureName': 'basis'}} rankDict = {'featureKey': 'rank', 'featureId': 'rank', 'params': {'period': 5, 'featureName': 'stockVWAP'}} bbandlowerDict = {'featureKey': 'bollinger_bands_lower', 'featureId': 'bollinger_bands_lower', 'params': {'period': 30, 'featureName': 'stockVWAP'}} bbandupperDict = {'featureKey': 'bollinger_bands_upper', 'featureId': 'bollinger_bands_upper', 'params': {'period': 30, 'featureName': 'stockVWAP'}} rsi = {'featureKey': 'rsi', 'featureId': 'rsi', 'params': {'period': 5, 'featureName': 'basis'}} vwap = {'featureKey': 'vwap', 'featureId': 'vwap'} fees = {'featureKey': 'fees', 'featureId': 'fees'} position = {'featureKey': 'position', 'featureId': 'position'} pnl = {'featureKey': 'pnl', 'featureId': 'pnl'} capital = {'featureKey': 'capital', 'featureId': 'capital'} portfolio_value = {'featureKey': 'portfolio_value', 'featureId': 'portfolio_value'} macd = {'featureKey': 'macd', 'featureId': 'macd', 'params': {'period1': 5, 'period2': 10, 'featureName': 'basis'}} csm = {'featureKey': 'cross_sectional_momentum', 'featureId': 'cross_sectional_momentum', 'params': {'period': 5, 'featureName': 'basis'}} ratio = {'featureKey': 'ratio', 'featureId': 'ratio', 'params': {'instrumentId1': \"IBM\", 'instumentId2': \"MSFT\" 'featureName': 'basis'}}","title":"Examples"}]}